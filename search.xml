<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[MacOSX Sierra下Python3配置opencv]]></title>
      <url>%2F2016%2F12%2F28%2FMacOSX%20Sierra%E4%B8%8BPython3%E9%85%8D%E7%BD%AEopencv%2F</url>
      <content type="text"><![CDATA[编译注意事项opencv2 不支持 python3，为了在python3下使用opencv，需要使用opencv3。 通过 homebrew 安装可以通过 brew 也可以安装opencv。 1brew install opencv3 --with-python3 --c++11 --with-contrib --HEAD --with-ffmpeg brew 的一些参数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950--32-bit Build 32-bit only--c++11 Build using C++11 mode--with-contrib Build "extra" contributed modules--with-cuda Build with CUDA v7.0+ support--with-ffmpeg Build with ffmpeg support--with-gphoto2 Build with gphoto2 support--with-gstreamer Build with gstreamer support--with-jasper Build with jasper support--with-java Build with Java support--with-libdc1394 Build with libdc1394 support--with-opengl Build with OpenGL support (must use --with-qt5)--with-openni Build with openni support--with-openni2 Build with openni2 support--with-python3 Build with python3 support--with-qt Build the Qt4 backend to HighGUI--with-qt5 Build the Qt5 backend to HighGUI--with-quicktime Use QuickTime for Video I/O instead of QTKit--with-tbb Enable parallel code in OpenCV using Intel TBB--without-eigen Build without eigen support--without-numpy Use a numpy you've installed yourself instead of a Homebrew-packaged numpy--without-opencl Disable GPU code in OpenCV using OpenCL--without-openexr Build without openexr support--without-python Build without Python support--without-tests Build without accuracy &amp; performance tests--HEAD Install HEAD version 通过 cmake 安装下面是 cmake 的选项(请自行修改python对应的路径，如3.6.0、3.6等)。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546cmake \.. \-DCMAKE_C_FLAGS_RELEASE=-DNDEBUG \-DCMAKE_CXX_FLAGS_RELEASE=-DNDEBUG \-DCMAKE_INSTALL_PREFIX=/usr/local/Cellar/opencv3/HEAD-7dd3723_4 \-DCMAKE_BUILD_TYPE=Release \-DCMAKE_FIND_FRAMEWORK=LAST \-DCMAKE_VERBOSE_MAKEFILE=ON \-Wno-dev \-DBUILD_JASPER=OFF \-DBUILD_JPEG=ON \-DBUILD_TIFF=ON \-DBUILD_OPENEXR=ON \-DBUILD_PNG=ON \-DBUILD_ZLIB=ON \-DCMAKE_OSX_DEPLOYMENT_TARGET= \-DJPEG_INCLUDE_DIR=/usr/local/opt/jpeg/include \-DJPEG_LIBRARY=/usr/local/opt/jpeg/lib/libjpeg.dylib \-DBUILD_opencv_java=ON \-DBUILD_opencv_python2=ON \-DBUILD_opencv_python3=ON \-DBUILD_TESTS=ON \-DBUILD_PERF_TESTS=OFF \-DWITH_1394=OFF \-DWITH_EIGEN=ON \-DWITH_FFMPEG=ON \-DWITH_GPHOTO2=OFF \-DWITH_GSTREAMER=OFF \-DWITH_JASPER=OFF \-DWITH_OPENEXR=ON \-DWITH_OPENGL=OFF \-DWITH_QUICKTIME=OFF \-DWITH_QT=OFF \-DWITH_TBB=OFF \-DWITH_VTK=OFF \-DWITH_CUDA=OFF \-DOPENCV_EXTRA_MODULES_PATH=/Volumes/Data/share/opencv_contrib/modules \-DPYTHON2_EXECUTABLE=/usr/bin/python \-DPYTHON2_LIBRARY=/System/Library/Frameworks/Python.framework/Versions/2.7/lib/libpython2.7.dylib \-DPYTHON2_INCLUDE_DIR=/System/Library/Frameworks/Python.framework/Versions/2.7/include/python2.7 \-DPYTHON3_LIBRARY=/usr/local/opt/python3/Frameworks/Python.framework/Versions/3.6/lib/python3.6/config-3.6m-darwin/libpython3.6.dylib \-DPYTHON3_INCLUDE_DIR=/usr/local/Cellar/python3/3.6.0/Frameworks/Python.framework/Versions/3.6/include/python3.6m \-DENABLE_SSSE3=ON \-DENABLE_SSE41=ON \-DENABLE_SSE42=ON \-DENABLE_AVX=ON 之后执行 1make &amp;&amp; make install 找到编译完成的cv.so 文件，并创建软链接即可。 1ln -s /usr/local/Cellar/opencv3/HEAD-7dd3723_4/lib/python3.6/site-packages/cv2.cpython-36m-darwin.so /usr/local/lib/python3.6/site-packages/cv2.so 可能会遇到的问题需要注意的是：最新的Mac系统下编译Opencv 3.0 和 Opencv 3.1 可能会出错。该问题出现在OSX 10.12 之后的版本中，早期版本无此问题。opencv 3.2解决了该问题。 12345678910111213[ 2%] Built target zlib[ 6%] Built target libtiff[ 11%] Built target libjpeg[ 17%] Built target libwebp[ 21%] Built target libjasper[ 24%] Built target libpng[ 32%] Built target IlmImf[ 37%] Built target opencv_core[ 42%] Built target opencv_imgproc[ 43%] Built target opencv_imgcodecs[ 44%] Building CXX object modules/videoio/CMakeFiles/opencv_videoio.dir/src/cap_qtkit.mm.o/Volumes/Data/share/opencv-3.1.0/modules/videoio/src/cap_qtkit.mm:46:9: fatal error: 'QTKit/QTKit.h' file not found#import &lt;QTKit/QTKit.h&gt; 参考链接 http://www.pyimagesearch.com/2015/06/29/install-opencv-3-0-and-python-3-4-on-osx/ https://www.learnopencv.com/install-opencv-3-on-yosemite-osx-10-10-x/ https://github.com/opencv/opencv/releases/tag/3.2.0]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Comparison to None will result in an elementwise object]]></title>
      <url>%2F2016%2F12%2F13%2FComparison%20to%20None%20will%20result%20in%20an%20elementwise%20object%2F</url>
      <content type="text"><![CDATA[numpy数组和None进行比较时，可能导致意外的结果： 1234import numpy as npnp.array([0,1,2]) == None&gt; False&gt; FutureWarning: comparison to `None` will result in an elementwise object comparison in the future. 在此，我们应该选用is操作符。 You are looking for is: 1234if a is None: a = somethingelse: # TODO 下面是关于is的解释： The problem is that, by using the == operator, if the input element a is a numpy array, numpy will try to perform an element wise comparison and tell you that you cannot compare it. For a a numpy array, a == None gives error, np.all(a == None) doesn’t (but does not do what you expect). Instead a is None will work regardless the data type of a. From a java point of view, the python’s == would trigger java’s .equals, which in numpy is overrided to perform a element-wise check. Python’s is would be equivalent to check for reference in java (similar to using == with strings). However, for strings in python (i.e. a = ‘hello’; b = ‘hello’), the a is b would still return true, as both of them are the same constant (‘hello’) 除了 == 外，numpy还重载了__contains__即in运算符。下面是解释： The future warning happens when you do something like this: numpy.asarray([1,2,3,4]) == None Which currently returns False, but I understand will return an array containing [False,False,False,True] in a future version of Numpy. As I mentioned in the comments, your example is incorrect. Future versions of numpy would return [False ,False, False, False], i.e. False for each element in the array that is not equal to None. This is more consistent with how element-wise comparisons to other scalar values currently work, e.g.: 12345In [1]: np.array([1, 2, 3, 4]) == 1Out[1]: array([ True, False, False, False], dtype=bool)In [2]: np.array(['a', 'b', 'c', 'd']) == 'b'Out[2]: array([False, True, False, False], dtype=bool) What confuses me is this behaviour of the in keyword with a 1D array compared to a listWhen you test x in y, you are calling y.__contains__(x). When y is a list, __contains__basically does something along the lines of this: 1234for item in y: if (item is x) or (item == x): return Truereturn False As far as I can tell, np.ndarray.__contains__(x) performs the equivalent of this: 1234if any(y == x): return Trueelse: return False That is to say it tests element-wise equality over the whole array first (y == x would be a boolean array the size of y). Since in your case you are testing whether y == None, this will raise the FutureWarning for the reasons given above. In the comments you also wanted to know whynp.nan in np.array([1, 2, 3, np.nan])returns False, butnp.nan in [1, 2, 3, np.nan]returns True. The first part is easily explained by the fact that np.nan != np.nan (see here for the rationale behind this). To understand why the second case returns True, remember that list.__contains__() first checks for identity (is) before checking equality (==). Since np.nan is np.nan, the second case will return True. 参考链接： http://stackoverflow.com/questions/33954216/comparison-to-none-will-result-in-an-elementwise-object http://stackoverflow.com/questions/28337085/why-does-none-in-numpy-asarray-cause-a-future-warning]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[swig 使用说明]]></title>
      <url>%2F2016%2F12%2F10%2Fswig%20%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%2F</url>
      <content type="text"><![CDATA[SWIG是个帮助使用C或者C++编写的软件能与其它各种高级编程语言进行嵌入联接的开发工具。SWIG能应用于各种不同类型的语言包括常用脚本编译语言例如Perl, PHP, Python, Tcl, Ruby and PHP。支持语言列表中也包括非脚本编译语言，例如C#, Common Lisp (CLISP, Allegro CL, CFFI, UFFI), Java, Modula-3, OCAML以及R，甚至是编译器或者汇编的计划应用（Guile, MzScheme, Chicken）。SWIG普遍应用于创建高级语言解析或汇编程序环境，用户接口，作为一种用来测试C/C++或进行原型设计的工具。SWIG还能够导出XML或Lisp s-expressions格式的解析树。SWIG可以被自由使用，发布，修改用于商业或非商业中。 主要利用了C++转Python的方法和技巧。 首先，需要简单的了解C++和Python混合编程的知识。 对于已有的C++程序，我们希望其中的部分函数可以在Python中调用。当然我们可以通过学习C++和Python的混合编程知识，自己修改函数接口，但是上述过程比较复杂。swig就是为了自动话完成上述任务的。比如，对于一个C++函数，我们希望能够在添加Python的wrap，我们可以首先构建一个swig脚本，在脚本中注明我们希望调用的函数或者数据结构，然后swig就可以自动化的完成函数接口的wrap工作。 经过测试，在对C++程序添加Python的wrap时，swig可以很好的完成工作，但也存在一些问题。 Tutorial在使用swig 的过程中，首先，准备swig文件。一般以.i结束。下面是一个简单的swig文件test.i。 123456789101112%module test%header %&#123;#include "test1.h"#include "test2.h"%&#125;%ignore operator Point::operator &lt;&lt;;%rename (__add__) Point::operator +;%rename (__sub__) operator -;%include "test1.h"%include "test2.h" 注意：rename和ignore应该放置在%include 的前面，否则，rename和ignore并不会生效。 假设 test1.h 文件的内容如下所示： 1234567891011class Point &#123;public: Point operator + (const Point &amp; other); ostream operator &lt;&lt; (ostream &amp;os); Point(int x, int y);private: int x; int y;&#125;Point operator -(const Point &amp;p1, const Point&amp;p2); 其次，执行swig命令，生成swig的wrapper， 1swig -c++ -python test.i 执行该步骤后，在当前目录下生成两个文件：test.py，test_wrap.cxx。然后编译相关的函数： 1g++ -shared -fpic `pkg-config --cflags opencv` test_wrap.cxx test1.cpp test2.cpp -o _test.so `pkg-config --libs python` 注意：生成的so文件，命名为”test.so”，即module的名称加上前缀的``。该步骤执行完成后，理论上当前目录下应该生成 _test.so 文件。 在当前目录下，运行测试文件test_swig.py： 12345from test import *p1 = Point(1, 2)p2 = Point(3, 4)p3 = p1 + p2p4 = p2 - p1 swig 的依赖关系swig 的过程如果需要额外的头文件依赖，需要在命令行中加以说明： 1swig -c++ -python `pkg-config --cflags opencv` test.i 以及，在编译的时候也有可能需要指明额外的依赖，包括头文件和额外的库文件： 1g++ -shared -fpic `pkg-config --cflags python opencv` test_wrap.cxx test1.cpp test2.cpp -o _test.so `pkg-config --libs opencv python` 忽略部分函数在某些情况下，可能C++的部分函数和Python不完全兼容，为此，我们需要跳过某些函数。比如，流的重定向作用符； 1%ignore FlyPoints::&lt;&lt;; 需要说明的是，注意swig中的命名空间。 参考链接：http://stackoverflow.com/questions/22518497/ignore-redefinition-of-operator-in-swig-interface 重命名部分函数在某些情况下，我们希望重命名部分函数，或者变量名。比如： 1%rename (__add__) Points::operator +; enum 的使用C类型的enum直接被处理成了Python中的全局变量；C++ 11类型的 enum class 类型在引用时被mangle了。 123456789enum Weekday &#123; Mon, Tus, Wed, Thr, Fri, Sat, Sun&#125;;// Python =&gt; Mon, Tueenum class Weekday &#123; Mon, Tus, Wed, Thr, Fri, Sat, Sun&#125;;// Python =&gt; Weekday_Mon, Weekday_Tue 参考链接：http://stackoverflow.com/questions/13269393/how-to-enumerate-enum-members-using-swig swig 可能遇到的问题so文件的命名问题so 文件的明明需要和module一致，_$(module).so。否则在python中，执行import可能会报错： 12----&gt; 1 import FlyLibImportError: dynamic module does not define init function (initFlyLib) 文件的顺序问题比如，在test1.h文件中定义enum类型： 123enum Weekday &#123; Mon, Tue, Wed, Thr, Fri, Sat, Sun&#125;; 在 test2.h 中定义函数: 12#include "test1.h"bool isWeekends(Weekday day = Mon); 则在test.i文件中，test1.h最好放在test2.h文件前，否则，在python程序import时，会出现错误： 12345678910----&gt; 1 import test/Users/houqi/test.py in &lt;module&gt;() 100 101--&gt; 102 def isWeekends(day=Mon): 103 return _test.isWeekends(day) 104 isWeekends = _test.isWeekendsNameError: name 'Mon' is not defined python 的版本问题Python有Python2和Python3两个版本，在编译的时候需要分别指定。 12pkg-config --libs python2pkg-config --libs python3 以及，可能存在多个同一版本的python程序，比如，在Mac系统下，系统自带的Python和brew安装的Python以及Anaconda自带的Python。如果编译过程中指定的Python库和运行的Python程序不一致，在import时可能会出错。 在cmake下，可以通过命令行参数指定： 12345cmake \-DTEST_PYTHON_VERSION=2 \-DPYTHON_EXECUTABLE:FILEPATH=/usr/local/Cellar/python/2.7.12_2/Frameworks/Python.framework/Versions/2.7/bin/python \-DPYTHON_LIBRARIES=/usr/local/Cellar/python/2.7.12_2/Frameworks/Python.framework/Versions/2.7/lib/libpython2.7.dylib \.. 类的静态数组变量swig 好像不支持类的静态数组变量。 swig 的详细说明文件Swig 的参考资料： http://www.swig.org/translations/chinese/tutorial.html http://www.swig.org/Doc1.3/SWIGPlus.html http://www.swig.org/Doc3.0/CPlusPlus11.html swig + opencv参考链接：https://github.com/renatoGarcia/opencv-swig]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python 的字符编码]]></title>
      <url>%2F2016%2F10%2F13%2FPython-%E7%9A%84%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%2F</url>
      <content type="text"><![CDATA[Python默认使用的是UTF-8编码格式。存储方式有两种：str 和 unicode 编码。其中，str的存储单位为 byte，为unicode格式存储的是字符。比如说，str类型下， 123x = u'你好，python域编码'x --&gt; u'\u4f60\u597d\uff0cpython\u57df\u7f16\u7801'x[0] --&gt; u'\u4f60' 但是如果执行print x[0]， 得到的结果将会是”你”。可以将unicode编码转换为 utf-8 格式。 12y = x.encode('utf-8')y --&gt; '\xe4\xbd\xa0\xe5\xa5\xbd\xef\xbc\x8cpython\xe5\x9f\x9f\xe7\xbc\x96\xe7\xa0\x81' 如果执行print y,只会输出无意义字符。上述操作的逆操作：y.decode(&#39;utf-8&#39;)需要注意：在python中，默认的编码是utf-8格式，在处理的时候需要注意，最好采用统一的格式。 Python中检测编码的库：chardet，用法如下： 12import chardetchardet.detect(open('xxx', 'r').read()) 得到类似 {&#39;confidence&#39;: 0.99, &#39;encoding&#39;: &#39;GB2312&#39;} 的结果。 参考链接： http://www.jb51.net/article/62155.htm Python中读写不同编码的库 codecs 12f = codecs.open(file_name, 'r', 'utf-8-sig')f = codecs.open(file_name, 'w', 'gb2312') 其他操作和普通的文件读写很类似。注意UTF-8 with BOM，codecs.UTF8_BOM]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2016%2F10%2F13%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
